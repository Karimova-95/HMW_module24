============================ Модуль 24.7 =======================================

1. Создать новый проект в IntelliJ IDEA. При создании выбрать вариант через Maven, без использования архетипов.
2. Подключить зависимости для Apache Commons Lang, Apache Commons Collections, Apache POI OOXML, использовать последние
   версии пакетов. Найти необходимую информацию по подключению можно на сайте.
3. Создать классы университета и студента (например, University и Student). Далее будем называть их модельными классами.
4. Создать enum StudyProfile с перечислением возможных специальностей (необязательно перечислять все существующие, хотя
   бы несколько для примера). Это должен быть enum с параметром. Назовём этот параметр String profileName, будем
   записывать в нём русскоязычные расшифровки направлений обучения. Например, профиль MEDICINE с параметром "Медицина".
5. Добавить в модельные классы набор полей на своё усмотрение, но обязательными являются:
   -для University — String id, String fullName, String shortName, int yearOfFoundation, StudyProfile mainProfile; -для
   Student — String fullName, String universityId, int currentCourseNumber, float avgExamScore.
6. Для написанных классов реализовать геттеры, сеттеры, конструкторы (как минимум, конструкторы по умолчанию), а также
   переопределить метод toString, чтобы он выводил текстовую информацию о значении всех полей класса.
7. При написании сеттеров рекомендуется воспользоваться шаблоном Builder. Можно посмотреть пример генерации сеттера по
   такому шаблону, встроенному в IntelliJ IDEA.
8. Создать класс с методом main для запуска приложения. В методе main создать экземпляры созданных модельных классов,
   наполнить их какими-нибудь тестовыми данными и вывести в консоль их значения. Вывод должен работать без
   дополнительных вызовов геттеров и так далее, простой передачей экземпляра на вход System.out.println().

============================ Модуль 25.9 =======================================

1. Скачать подготовленный файл XLSX(в resources). При желании можно продолжить заполнение файла произвольной подходящей
   информацией.
2. Разместить этот файл в папку ресурсов проекта.
3. Создать класс, отвечающий за чтение файла и создание из него коллекций студентов и университетов. В файле необходимо
   реализовать запрет на создание экземпляра (приватный конструктор).
4. В файле необходимо реализовать два метода: один — для чтения студентов, второй — для чтения университетов. При чтении
   эти методы должны построчно читать табличный файл и собирать коллекции соответствующих элементов классов.
5. Реализовать занесение в класс University значения типа StudyProfile. Для этого необходимо текстовое поле из файла
   преобразовать в элемент enum.
6. Очистить метод main от предыдущего кода. Вместо этого реализовать получение коллекций с использованием написанного в
   п.4 класса, затем вывести в консоль все полученные элементы коллекций.
7. Дополнительное задание (теоретическое): разобраться, почему для Apache POI оказалось достаточно использовать только
   одну подключенную в Maven зависимость без указания других частей POI, которые, казалось бы, тоже надо упоминать.
   Создать интерфейсы-компараторы для классов Student, University. Унаследовать их от класса Comparator<>. Для каждого
   поля классов Student, University создать классы-компараторы, реализующие интерфейс созданных в п.1 компараторов. При
   сравнении значений в методе compare() использовать методы соответствующих классов (Integer, Float, ...), для
   строковых значений использовать метод StringUtils.compare() библиотеки Apache Commons. Сравнение среднего балла
   студентов реализовать по убыванию. Создать два enum, один — для перечисления вариантов компараторов класса Student,
   второй — класса University. Создать утилитный класс (то есть класс, не позволяющий создать свой экземпляр, работающий
   исключительно по статическим методам), в котором реализовать два метода, принимающих на вход enum с типом
   компаратора, определяющих и возвращающих необходимый из реализованных компараторов. Пояснение: на вход метода
   подаётся параметр, представляющий собой enum. Например, вот так: public static IMyComparator getMyComparator(MyEnum
   myEnum). Внутри метода по этому значению определяем, какую реализацию компаратора надо взять. На выходе метода, как
   видно из его описания, мы получаем тот или иной объект, реализующий наш интерфейс компаратора.

============================ Модуль 26.9 =======================================

1. Создать интерфейсы-компараторы для классов Student, University. Унаследовать их от класса Comparator<>.
2. Для каждого поля классов Student, University создать классы-компараторы, реализующие интерфейс созданных в п.1
   компараторов.
3. При сравнении значений в методе compare() использовать методы соответствующих классов (Integer, Float, ...), для
   строковых значений использовать метод StringUtils.compare() библиотеки Apache Commons. Сравнение среднего балла
   студентов реализовать по убыванию.
4. Создать два enum, один — для перечисления вариантов компараторов класса Student, второй — класса University.
5. Создать утилитный класс (то есть класс, не позволяющий создать свой экземпляр, работающий исключительно по
   статическим методам), в котором реализовать два метода, принимающих на вход enum с типом компаратора, определяющих и
   возвращающих необходимый из реализованных компараторов. Пояснение: на вход метода подаётся параметр, представляющий
   собой enum. Например, вот так:
   public static IMyComparator getMyComparator(MyEnum myEnum). Внутри метода по этому значению определяем, какую
   реализацию компаратора надо взять. На выходе метода, как видно из его описания, мы получаем тот или иной объект,
   реализующий наш интерфейс компаратора.
6. В методе main реализовать получение компаратора по типу (вызов метода утилитного класса). Сохранить полученные
   значения (то есть экземпляры компараторов) в переменные с типом интерфейса компаратора (аналогично тому, как в
   коллекциях делается List<T> someList = new ArrayList()).
7. В методе main заменить циклический вывод текстовой информации на использование Stream API. Перед выводом выполнить
   сортировку с использованием полученных компараторов. Вывод реализовать также в стриме с использованием синтаксиса ::

============================ PRACTICE =======================================

1. Добавить в pom.xml зависимость для библиотеки Google Gson.
2. Данные для подключения можно взять на сайте. Создать утилитный класс JsonUtil. Запретить создание экземпляра класса.
3. В классе JsonUtil реализовать 4 метода сериализации в JSON и 4 метода десериализации из JSON в объекты:
   сериализация/десериализация отдельных объектов студентов и университетов, сериализация/десериализация коллекций этих
   объектов. Сериализация должна выполняться в форматированном виде (PrettyPrinting).
4. В методе main выполнить сериализацию коллекций, вывести получившиеся JSON-строки в консоль.
5. В методе main выполнить десериализацию полученных строк, сохранить результаты в новые коллекции.
6. Сравнить количество элементов в исходной и в десериализованной коллекциях, чтобы убедиться, что десериализация
   выполняется корректно.
7. С помощью Java Stream API выполнить для исходных коллекций сериализацию отдельных элементов.
8. Там же внутри стрима выводить получающиеся JSON-строки.
9. Там же внутри стрима десериализовывать объекты из полученных JSON-строк.
10. Там же внутри стрима выводить десериализованные объекты на печать, чтобы убедиться в корректности операции.
11. В классах Student и University добавить аннотации @SerializedName для каждого поля, чтобы изменить названия полей в
    сериализованном JSON-е. Названия можно изменить на произвольные, но подходящие по смыслу.
12. Убедиться в том, что сериализация/десериализация с измененными именами происходит также корректно.

============================ Модуль 29.5 =======================================

1. С помощью Java-аннотаций JAXB и создания классов организовать структуру, соответствующую требованиям, приведённым в
   конце урока. Структура должна строго соответствовать как по содержанию, так и по наименованию полей.
2. Создать класс, отвечающий за запись XML-файлов из Java-класса. В этом классе должен быть метод, принимающий на вход
   созданную в п.1 классовую структуру. Затем этот метод выполняет маршаллинг входных параметров и записывает в файл
   .xml. Рекомендуется с помощью Java-кода создать директорию и в неё складывать генерируемые файлы. Например,
   xmlReqs/req.xml.
3. Наименование файла должно содержать дату, когда этот файл был создан, либо её long-представление.
4. Содержимое XML-файла должно быть форматированным (то есть не одной строкой, с отступами).
5. Создать класс, отвечающий за запись JSON-файлов из Java-классов. В этом классе должен быть метод, принимающий на вход
   созданную в п.1 классовую структуру. Затем этот метод выполняет сериализацию входных данных в JSON-строки и
   записывает в файлы .json. Рекомендуется с помощью Java-кода создать директорию и в неё складывать генерируемые файлы.
   Например, jsonReqs/req.json.
6. Наименование файла должно содержать дату, когда был собрал объект из п.1, либо её long-представление.
7. ри сериализации использовать ранее созданный утилитный класс JsonUtil.
8. Дополнительное задание: переписать JsonUtil так, чтобы коллекции классов Student, University, Statistics
   обрабатывались одним общим методом, не привязанным к их типам.
9. Залогировать всё необходимое из созданного в этом уроке.
10. В методе main() после сортировок создать объект из п.1, вызвать генерацию XML-файлов и генерацию JSON-файлов.